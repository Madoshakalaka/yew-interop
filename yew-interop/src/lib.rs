use std::borrow::BorrowMut;
use std::cell::RefCell;
use std::collections::{HashMap, HashSet};
use std::rc::Rc;

use gloo_events::EventListener;

use wasm_bindgen::JsCast;
use wasm_bindgen::JsValue;
use wasm_bindgen::prelude::*;
use web_sys::{HtmlHeadElement, HtmlLinkElement, HtmlScriptElement};
use yew::callback::Callback;
use yew::prelude::*;
use yew_agent::{Agent, AgentLink, Bridged, Context, HandlerId};


#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_name = Toastify)]
    pub(crate) type Toast;

    #[wasm_bindgen(constructor, js_class = "Toastify")]
    pub fn new(config: &JsValue) -> Toast;

    #[wasm_bindgen(method, structural, js_class = "Toastify", js_name = showToast)]
    pub fn show_toast(this: &Toast);
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen]
    pub fn init_aos();
}

pub enum LinkType {
    Css,
    Js,
}

#[derive(Eq, PartialEq, Hash, Debug, Copy, Clone)]
pub struct Link {
    r#type: LinkType,
    src: &'static str,
}

// generated by macro
pub const TOAST_LINKS: (Link, Link) = (
    Link {
        r#type: LinkType::Js,
        src: "https://mycdn.com/toast.js",
    },
    Link {
        r#type: LinkType::Css,
        src: "https://mycdn.com/toast.css",
    }
);

pub fn use_toast_links() -> bool {
    let handle = use_context::<ToastLinkGroupStatusHandle>().unwrap();
    match handle {
        ToastLinkGroupStatusHandle::NotRequested(disp) => {
            disp.dispatch(LinkGroupStatusAction::PleaseStart(vec![
                Link {
                    r#type: LinkType::Js,
                    src: "https://mycdn.com/toast.js",
                },
                Link {
                    r#type: LinkType::Css,
                    src: "https://mycdn.com/toast.css",
                }
            ]));
            false
        }
        ToastLinkGroupStatusHandle::Started => false,
        ToastLinkGroupStatusHandle::Completed => true
    }
}

// dispatcher: UseReducerDispatcher<LinkGroupStatus>

// struct ToastLinkGroupStatus((bool, Option<UseReducerDispatcher<ToastLinkGroupStatus>>));

// generated by macro
enum ToastLinkGroupStatusHandle {
    NotRequested(UseReducerDispatcher<LinkGroupStatus>),
    Started,
    Completed,
}


enum LinkGroupStatusAction {
    PleaseStart(Vec<Link>),
    Completed,
}

#[derive(PartialEq, Clone)]
pub enum LinkGroupStatus {
    NotRequested,
    Started {links: Vec<Link> },
    Completed { links: Vec<Link> },
}

impl Default for LinkGroupStatus {
    fn default() -> Self {
        Self::NotRequested
    }
}

impl Reducible for LinkGroupStatus {
    type Action = LinkGroupStatusAction;

    fn reduce(self: Rc<Self>, action: Self::Action) -> Rc<Self> {
        match action {
            LinkGroupStatusAction::PleaseStart(links) => {
                match &self.0 {
                    LinkGroupStatus::NotRequested => Rc::new(Self::Started {links}),
                    _ => self
                }
            },
            LinkGroupStatusAction::Completed => {
                match &self.0 {
                    LinkGroupStatus::NotRequested => unreachable!("resource not requested but received completed message"),
                    LinkGroupStatus::Completed { .. } => unreachable!("resource is already completed but received more completed message"),
                    LinkGroupStatus::Started { links} => {
                        Rc::new(Self::Completed { links: links.clone() })
                    }
                }
            }
        }
    }
}

#[derive(Properties, PartialEq)]
pub struct LinkResourceManagerProps {
    pub children: Children,
}

#[function_component(LinkResourceManager)]
pub fn link_resource_manager(props: &LinkResourceManagerProps) -> Html {
    let toast_link_group_status = use_reducer(|| LinkGroupStatus::default);

    // macro generated
    thread_local!{
            pub static TOAST_REMAINING: RefCell<u8> = RefCell::new(2);
    }

    let make_links_with_onload = |links: Vec<Link>, onload: Option<Callback<Event>>|{
        html!{
            <>
                {for
                    links.into_iter().map(|link| {
                        match link.r#type {
                            LinkType::Js => html_nested! {
                                <script src={link.src} {onload}/>
                            },
                            LinkType::Css => html_nested! {
                                <link rel="stylesheet" href={link.src} {onload}/>
                            }
                        }
                        }
                    )
                }
            </>
        }
    };

    let produce_not_completed_links = |links: Vec<Link>, dispatcher: UseReducerDispatcher<LinkGroupStatus>| {

        let onload = move |_| {
            TOAST_REMAINING.with(|r|{
                let current = *r.borrow();
                *r.borrow_mut() = current - 1;
                if current > 1 {
                    *r.borrow_mut() = current - 1
                } else {
                    dispatcher.dispatch(LinkGroupStatusAction::Completed)
                }
            })
        };

        make_links_with_onload(links, Callback::from(onload))
    };
    let (toast_link_handle, toast_links) = match *toast_link_group_status {
        LinkGroupStatus::Started {links} => (ToastLinkGroupStatusHandle::Started,
                                             produce_not_completed_links(links, toast_link_group_status.dispatcher())),
        LinkGroupStatus::Completed{links} => (ToastLinkGroupStatusHandle::Completed,
                                              make_links_with_onload(links, None)),
        LinkGroupStatus::NotRequested => (ToastLinkGroupStatusHandle::NotRequested(toast_link_group_status.dispatcher()), html!{})
    };


    let portal = create_portal(toast_links, gloo_utils::document().head().unwrap());

    html! {
        <>
            <ContextProvider<ToastLinkGroupStatusHandle> context={toast_link_handle}>
                {children}
            </ContextProvider<ToastLinkGroupStatusHandle>
            {portal}
        </>
    }
}